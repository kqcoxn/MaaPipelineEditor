# 执行上下文

<cite>
**本文引用的文件**
- [context.go](file://context.go)
- [context_test.go](file://context_test.go)
- [tasker.go](file://tasker.go)
- [job.go](file://job.go)
- [pipeline.go](file://pipeline.go)
- [rect.go](file://rect.go)
- [node.go](file://node.go)
- [node_recognition.go](file://node_recognition.go)
- [node_action.go](file://node_action.go)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go)
- [internal/buffer/string_buffer.go](file://internal/buffer/string_buffer.go)
- [internal/native/framework.go](file://internal/native/framework.go)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go)
</cite>

## 更新摘要
**变更内容**
- 新增直接执行方法：RunRecognitionDirect 和 RunActionDirect
- 改进错误处理机制，提供更详细的错误信息
- 增强 OverridePipeline 方法的参数支持
- 新增 WaitFreezes 方法用于屏幕稳定检测
- 完善 GetNode 方法用于节点数据解析

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构总览](#架构总览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考量](#性能考量)
8. [故障排查指南](#故障排查指南)
9. [结论](#结论)
10. [附录](#附录)

## 简介
本文件为 Context 组件的详尽 API 参考文档，面向希望在任务执行过程中灵活控制识别、动作与流水线行为的开发者。Context 提供了以下关键能力：
- 执行任务并返回详细信息（支持错误处理）
- 执行图像识别并返回识别详情（支持错误处理）
- 执行动作并返回动作详情（支持错误处理）
- 直接执行识别和动作（无需流水线入口）
- 覆盖流水线配置（支持 JSON 字符串或可序列化对象）
- 覆盖下一个节点列表
- 覆盖图像资源
- 获取节点 JSON 与解析后的节点数据
- 获取当前任务作业与关联的任务管理器
- 克隆上下文
- 设置/获取锚点
- 获取/清空命中计数
- 屏幕稳定检测（WaitFreezes）

上述所有方法均支持 override 参数以 JSON 字符串或可序列化对象的形式传入，便于在运行时动态调整节点行为。

## 项目结构
Context 的实现位于顶层模块中，并通过内部缓冲区与原生绑定进行交互。其主要依赖包括：
- 任务管理器 Tasker：用于查询任务详情、状态与作业
- 作业 Job/TaskJob：封装异步任务的状态查询与等待
- 管道定义 Pipeline/Node：描述节点属性与行为
- 原生接口 native：桥接 Go 与底层框架
- 缓冲区 buffer：图像与字符串等跨语言传递的中间层
- 节点参数类型：NodeRecognitionParam 和 NodeActionParam

```mermaid
graph TB
subgraph "Go 层"
Ctx["Context<br/>执行上下文"]
Tsk["Tasker<br/>任务管理器"]
Job["Job/TaskJob<br/>作业与任务作业"]
Pipe["Pipeline/Node<br/>节点与流水线"]
ImgBuf["ImageBuffer/StringBuffer<br/>缓冲区"]
Rect["Rect<br/>矩形区域"]
NodeTypes["NodeRecognitionParam<br/>NodeActionParam<br/>节点参数类型"]
end
subgraph "原生层"
Native["native<br/>MaaContext* 接口"]
end
Ctx --> Tsk
Ctx --> Job
Ctx --> Pipe
Ctx --> ImgBuf
Ctx --> Rect
Ctx --> NodeTypes
Ctx --> Native
Tsk --> Native
Job --> Native
Pipe --> Native
ImgBuf --> Native
```

**图表来源**
- [context.go](file://context.go#L1-L472)
- [tasker.go](file://tasker.go#L1-L120)
- [job.go](file://job.go#L1-L96)
- [pipeline.go](file://pipeline.go#L1-L120)
- [node.go](file://node.go#L1-L549)
- [node_recognition.go](file://node_recognition.go#L1-L861)
- [node_action.go](file://node_action.go#L1-L864)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go#L1-L130)
- [internal/buffer/string_buffer.go](file://internal/buffer/string_buffer.go#L1-L58)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)

**章节来源**
- [context.go](file://context.go#L1-L472)
- [tasker.go](file://tasker.go#L1-L120)
- [job.go](file://job.go#L1-L96)
- [pipeline.go](file://pipeline.go#L1-L120)
- [node.go](file://node.go#L1-L549)
- [node_recognition.go](file://node_recognition.go#L1-L861)
- [node_action.go](file://node_action.go#L1-L864)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go#L1-L130)
- [internal/buffer/string_buffer.go](file://internal/buffer/string_buffer.go#L1-L58)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)

## 核心组件
- **Context**：执行上下文，封装与底层框架交互的入口，提供任务、识别、动作、流水线覆盖、节点数据查询、锚点与命中计数等能力。
- **Tasker**：任务管理器，负责提交任务、查询状态、获取任务详情与作业。
- **Job/TaskJob**：作业抽象，提供状态查询与等待完成的能力。
- **Pipeline/Node**：流水线与节点模型，描述识别、动作、下一跳、超时、重试等属性。
- **Rect**：矩形区域类型，用于动作目标与识别 ROI。
- **缓冲区 buffer**：图像与字符串缓冲，用于跨语言传递原始数据。
- **节点参数类型**：NodeRecognitionParam 和 NodeActionParam，定义识别和动作的具体参数结构。

**章节来源**
- [context.go](file://context.go#L1-L472)
- [tasker.go](file://tasker.go#L1-L120)
- [job.go](file://job.go#L1-L96)
- [pipeline.go](file://pipeline.go#L1-L120)
- [rect.go](file://rect.go#L1-L6)
- [node.go](file://node.go#L1-L549)
- [node_recognition.go](file://node_recognition.go#L1-L861)
- [node_action.go](file://node_action.go#L1-L864)

## 架构总览
Context 在执行任务、识别与动作时，会将 Go 层的数据转换为底层框架可接受的句柄或 JSON 字符串，并通过原生接口调用底层能力。同时，Context 通过 Tasker 获取任务详情与作业，从而实现对任务生命周期的掌控。新增的直接执行方法允许开发者绕过流水线入口直接执行识别和动作，提供更大的灵活性。

```mermaid
sequenceDiagram
participant Caller as "调用方"
participant Ctx as "Context"
participant Tsk as "Tasker"
participant Native as "MaaContext* 原生接口"
Caller->>Ctx : RunTask(entry, override...)
Ctx->>Native : MaaContextRunTask(handle, entry, overrideJSON)
Native-->>Ctx : taskId
Ctx->>Tsk : GetTasker()
Tsk-->>Ctx : Tasker 实例
Ctx->>Tsk : getTaskDetail(taskId)
Tsk-->>Ctx : TaskDetail 或错误
Ctx-->>Caller : TaskDetail 或错误
Caller->>Ctx : RunRecognitionDirect(type, param, img)
Ctx->>Ctx : Marshal(param)
Ctx->>Native : MaaContextRunRecognitionDirect(handle, type, paramJSON, imgHandle)
Native-->>Ctx : recId
Ctx->>Tsk : getRecognitionDetail(recId)
Tsk-->>Ctx : RecognitionDetail 或错误
Ctx-->>Caller : RecognitionDetail 或错误
```

**图表来源**
- [context.go](file://context.go#L38-L94)
- [context.go](file://context.go#L200-L235)
- [tasker.go](file://tasker.go#L141-L238)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)

## 详细组件分析

### Context 结构体与方法总览
- **结构体字段**
  - handle：底层上下文句柄，用于与原生接口交互
- **方法族**
  - **任务执行**：RunTask(entry, override...) -> (*TaskDetail, error)
  - **图像识别**：RunRecognition(entry, img, override...) -> (*RecognitionDetail, error)
  - **动作执行**：RunAction(entry, box, recognitionDetail, override...) -> (*ActionDetail, error)
  - **直接识别**：RunRecognitionDirect(type, param, img) -> (*RecognitionDetail, error)
  - **直接动作**：RunActionDirect(type, param, box, recoDetail) -> (*ActionDetail, error)
  - **流水线覆盖**：OverridePipeline(override any) -> error
  - **下一跳覆盖**：OverrideNext(name string, nextList []NodeNextItem) -> error
  - **图像覆盖**：OverrideImage(imageName string, image image.Image) -> error
  - **节点数据**：GetNodeJSON(name string) -> (string, error)，GetNode(name string) -> (*Node, error)
  - **当前任务**：GetTaskJob() -> *TaskJob，GetTasker() -> *Tasker
  - **屏幕稳定**：WaitFreezes(duration time.Duration, box *Rect, waitFreezesParam...) -> bool
  - **上下文克隆**：Clone() -> *Context
  - **锚点**：SetAnchor(anchorName, nodeName string) -> error，GetAnchor(anchorName string) -> (string, error)
  - **命中计数**：GetHitCount(nodeName string) -> (uint64, error)，ClearHitCount(nodeName string) -> error

**章节来源**
- [context.go](file://context.go#L12-L472)

### RunTask：执行任务并返回详细信息
- **参数**
  - entry：任务入口节点名称
  - override...：可选参数，支持 JSON 字符串或任意可序列化对象；仅使用第一个参数
- **返回值**
  - (*TaskDetail, error)：任务详情；失败时返回错误
- **使用场景**
  - 在自定义动作中临时覆盖流水线后执行任务
  - 与 Tasker.PostTask 配合，统一管理任务生命周期
- **处理流程**
  - 将 override 转换为 JSON 字符串
  - 调用原生接口执行任务并获取 taskId
  - 通过 Tasker 查询任务详情
  - 如果执行失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L28-L53)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L75-L77)
- [context.go](file://context.go#L38-L45)
- [tasker.go](file://tasker.go#L285-L344)
- [context_test.go](file://context_test.go#L28-L53)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### RunRecognition：执行图像识别并返回识别详情
- **参数**
  - entry：识别节点名称
  - img：输入图像
  - override...：可选参数，支持 JSON 字符串或任意可序列化对象；仅使用第一个参数
- **返回值**
  - (*RecognitionDetail, error)：识别详情；失败时返回错误
- **使用场景**
  - 在自定义识别中临时覆盖识别参数（如 ROI）后执行识别
  - 与自定义识别配合，动态调整识别范围或算法参数
- **处理流程**
  - 将 override 转换为 JSON 字符串
  - 将 image.Image 包装为图像缓冲并传入原生接口
  - 通过 Tasker 查询识别详情
  - 如果执行失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L78-L109)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L124-L130)
- [context.go](file://context.go#L79-L94)
- [tasker.go](file://tasker.go#L141-L195)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go#L1-L130)
- [context_test.go](file://context_test.go#L78-L109)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### RunAction：执行动作并返回动作详情
- **参数**
  - entry：动作节点名称
  - box：动作目标矩形区域
  - recognitionDetail：识别结果的 DetailJson
  - override...：可选参数，支持 JSON 字符串或任意可序列化对象；仅使用第一个参数
- **返回值**
  - (*ActionDetail, error)：动作详情；失败时返回错误
- **使用场景**
  - 在自定义动作中根据识别结果决定点击坐标或滑动参数
  - 与自定义动作配合，动态调整动作参数
- **处理流程**
  - 将 override 转换为 JSON 字符串
  - 将 Rect 包装为矩形缓冲并传入原生接口
  - 通过 Tasker 查询动作详情
  - 如果执行失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L130-L155)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L186-L198)
- [context.go](file://context.go#L132-L154)
- [tasker.go](file://tasker.go#L197-L238)
- [rect.go](file://rect.go#L1-L6)
- [context_test.go](file://context_test.go#L130-L155)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### RunRecognitionDirect：直接执行图像识别
- **参数**
  - recoType：识别类型（NodeRecognitionType）
  - recoParam：识别参数（NodeRecognitionParam）
  - img：输入图像
- **返回值**
  - (*RecognitionDetail, error)：识别详情；失败时返回错误
- **使用场景**
  - 直接执行特定类型的识别，无需流水线入口
  - 快速测试识别参数或进行一次性识别
- **处理流程**
  - 将 NodeRecognitionParam 序列化为 JSON
  - 将 image.Image 包装为图像缓冲并传入原生接口
  - 通过 Tasker 查询识别详情
  - 如果执行失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L1393-L1418)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L209-L235)
- [context_test.go](file://context_test.go#L1376-L1418)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### RunActionDirect：直接执行动作
- **参数**
  - actionType：动作类型（NodeActionType）
  - actionParam：动作参数（NodeActionParam）
  - box：动作目标矩形区域
  - recoDetail：识别详情（可为 nil）
- **返回值**
  - (*ActionDetail, error)：动作详情；失败时返回错误
- **使用场景**
  - 直接执行特定类型的动作，无需流水线入口
  - 快速测试动作参数或进行一次性动作执行
- **处理流程**
  - 将 NodeActionParam 序列化为 JSON
  - 将 Rect 包装为矩形缓冲并传入原生接口
  - 将 RecognitionDetail 序列化为 JSON（如果提供）
  - 通过 Tasker 查询动作详情
  - 如果执行失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L1435-L1460)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L247-L279)
- [context_test.go](file://context_test.go#L1420-L1460)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### OverridePipeline：覆盖流水线配置
- **参数**
  - override：支持 JSON 字符串、字节切片或任意可序列化对象
- **返回值**
  - error：覆盖操作的错误状态
- **使用场景**
  - 在自定义动作/识别中临时修改节点参数（如 ROI、阈值、模板等）
  - 与 RunTask/RunRecognition/RunAction 搭配，按需覆盖
- **处理流程**
  - 将 override 转换为 JSON 字符串
  - 调用原生接口覆盖流水线
  - 如果覆盖失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L191-L216)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L312-L329)
- [context.go](file://context.go#L281-L286)
- [context_test.go](file://context_test.go#L191-L216)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### OverrideNext：覆盖下一个节点列表
- **参数**
  - name：节点名称
  - nextList：下一跳节点名称列表
- **返回值**
  - error：覆盖操作的错误状态
- **使用场景**
  - 在自定义动作中动态改变下一跳顺序或目标
- **处理流程**
  - 将字符串列表包装为字符串列表缓冲并传入原生接口
  - 如果覆盖失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L247-L272)

**章节来源**
- [context.go](file://context.go#L333-L352)
- [context_test.go](file://context_test.go#L247-L272)

### OverrideImage：覆盖图像资源
- **参数**
  - imageName：图像资源名
  - image：输入图像
- **返回值**
  - error：覆盖操作的错误状态
- **使用场景**
  - 在自定义识别中临时替换模板图或检测图
- **处理流程**
  - 将 image.Image 包装为图像缓冲并传入原生接口
  - 如果覆盖失败，返回详细的错误信息
- **示例路径**
  - [context.go](file://context.go#L355-L363)

**章节来源**
- [context.go](file://context.go#L355-L363)

### GetNodeJSON / GetNode：获取节点数据
- **GetNodeJSON(name)**
  - 返回：(string, error)；字符串为节点 JSON，错误表示获取状态
- **GetNode(name)**
  - 返回：(*Node, error)；解析失败时返回错误
- **使用场景**
  - 在自定义识别/动作中读取节点参数（如 ROI、阈值、模板等）
- **处理流程**
  - 通过原生接口获取节点 JSON
  - 将 JSON 解析为 Node 结构体
  - 如果获取失败，返回详细的错误信息
- **示例路径**
  - [context_test.go](file://context_test.go#L1234-L1263)
  - [context_test.go](file://context_test.go#L274-L420)

**章节来源**
- [context.go](file://context.go#L366-L390)
- [context_test.go](file://context_test.go#L1234-L1263)
- [context_test.go](file://context_test.go#L274-L420)

### GetTaskJob / GetTasker：获取当前任务作业与任务管理器
- **GetTaskJob()**
  - 返回：*TaskJob；基于当前上下文的任务 ID 与 Tasker 的状态/等待函数构造
- **GetTasker()**
  - 返回：*Tasker；从上下文句柄获取 Tasker 实例
- **使用场景**
  - 在自定义动作中查询任务状态、等待任务完成或获取任务详情
- **示例路径**
  - [context.go](file://context.go#L393-L410)
- **章节来源**
  - [context.go](file://context.go#L393-L410)

### WaitFreezes：屏幕稳定检测
- **参数**
  - duration：稳定持续时间
  - box：可选的检测区域（可为 nil）
  - waitFreezesParam：可选的等待参数（JSON 字符串或可序列化对象）
- **返回值**
  - bool：屏幕是否稳定
- **使用场景**
  - 等待屏幕状态稳定，避免误识别
  - 在动作前后进行屏幕稳定性检测
- **处理流程**
  - 将 Rect 包装为矩形缓冲（如果提供）
  - 将 waitFreezesParam 转换为 JSON 字符串
  - 调用原生接口进行屏幕稳定检测
- **示例路径**
  - [context_test.go](file://context_test.go#L1-L26)
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L418-L428)
- [context_test.go](file://context_test.go#L1-L26)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### Clone：克隆上下文
- **参数**：无
- **返回**：*Context；克隆后的上下文拥有独立句柄
- **使用场景**
  - 在自定义识别/动作中创建独立上下文，避免相互影响
- **示例路径**
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

**章节来源**
- [context.go](file://context.go#L431-L434)
- [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)

### SetAnchor / GetAnchor：设置/获取锚点
- **SetAnchor(anchorName, nodeName)**
  - 返回：error；设置操作的错误状态
- **GetAnchor(anchorName)**
  - 返回：(string, error)；锚点指向的节点名与错误状态
- **使用场景**
  - 在自定义识别/动作中记录运行时锚点，后续节点可通过锚点引用
- **示例路径**
  - [context.go](file://context.go#L437-L453)

**章节来源**
- [context.go](file://context.go#L437-L453)

### GetHitCount / ClearHitCount：获取/清空命中计数
- **GetHitCount(nodeName)**
  - 返回：(uint64, error)；命中次数与错误状态
- **ClearHitCount(nodeName)**
  - 返回：error；清空操作的错误状态
- **使用场景**
  - 在自定义识别/动作中统计节点命中次数或重置计数
- **示例路径**
  - [context.go](file://context.go#L456-L471)

**章节来源**
- [context.go](file://context.go#L456-L471)

### override 参数支持 JSON 字符串或可序列化对象的处理逻辑
- **Context 内部提供 handleOverride 与 OverridePipeline 的通用处理逻辑，支持：**
  - string：直接使用
  - []byte：转换为 string 后使用
  - 其他类型：尝试 JSON 序列化，失败则回退为空 JSON
- **这种设计使得在运行时可以灵活地以结构化数据覆盖节点参数，提升可维护性与可读性。**

**章节来源**
- [context.go](file://context.go#L19-L36)
- [context.go](file://context.go#L312-L329)

### 任务执行流程（RunTask）时序图
```mermaid
sequenceDiagram
participant Dev as "开发者"
participant Ctx as "Context"
participant Tsk as "Tasker"
participant N as "MaaContext*"
Dev->>Ctx : RunTask("Task", override)
Ctx->>Ctx : handleOverride(override)
Ctx->>N : MaaContextRunTask(handle, "Task", overrideJSON)
N-->>Ctx : taskId 或 0
alt 执行成功
Ctx->>Tsk : GetTasker()
Tsk-->>Ctx : Tasker
Ctx->>Tsk : getTaskDetail(taskId)
Tsk-->>Ctx : TaskDetail
Ctx-->>Dev : TaskDetail
else 执行失败
Ctx-->>Dev : 错误
end
```

**图表来源**
- [context.go](file://context.go#L75-L77)
- [context.go](file://context.go#L38-L45)
- [tasker.go](file://tasker.go#L285-L344)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)

### 识别流程（RunRecognition）时序图
```mermaid
sequenceDiagram
participant Dev as "开发者"
participant Ctx as "Context"
participant Tsk as "Tasker"
participant Buf as "ImageBuffer"
participant N as "MaaContext*"
Dev->>Ctx : RunRecognition("Task", img, override)
Ctx->>Buf : NewImageBuffer/Set(img)
Ctx->>Ctx : handleOverride(override)
Ctx->>N : MaaContextRunRecognition(handle, "Task", overrideJSON, imgHandle)
N-->>Ctx : recId 或 0
alt 执行成功
Ctx->>Tsk : getRecognitionDetail(recId)
Tsk-->>Ctx : RecognitionDetail
Ctx-->>Dev : RecognitionDetail
else 执行失败
Ctx-->>Dev : 错误
end
```

**图表来源**
- [context.go](file://context.go#L124-L130)
- [context.go](file://context.go#L79-L94)
- [tasker.go](file://tasker.go#L141-L195)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go#L1-L130)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)

### 动作流程（RunAction）时序图
```mermaid
sequenceDiagram
participant Dev as "开发者"
participant Ctx as "Context"
participant Tsk as "Tasker"
participant R as "RectBuffer"
participant N as "MaaContext*"
Dev->>Ctx : RunAction("Task", box, detailJson, override)
Ctx->>R : NewRectBuffer/Set(box)
Ctx->>Ctx : handleOverride(override)
Ctx->>N : MaaContextRunAction(handle, "Task", overrideJSON, boxHandle, detailJson)
N-->>Ctx : actId 或 0
alt 执行成功
Ctx->>Tsk : getActionDetail(actId)
Tsk-->>Ctx : ActionDetail
Ctx-->>Dev : ActionDetail
else 执行失败
Ctx-->>Dev : 错误
end
```

**图表来源**
- [context.go](file://context.go#L186-L198)
- [context.go](file://context.go#L132-L154)
- [tasker.go](file://tasker.go#L197-L238)
- [rect.go](file://rect.go#L1-L6)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)

### 节点数据解析流程（GetNode）流程图
```mermaid
flowchart TD
Start(["开始"]) --> GetJSON["调用 GetNodeJSON(name)"]
GetJSON --> Found{"存在节点?"}
Found --> |否| ReturnErr["返回错误"]
Found --> |是| Parse["解析 JSON 为 Node"]
Parse --> ParseOK{"解析成功?"}
ParseOK --> |否| ReturnErr
ParseOK --> |是| ReturnNode["返回 Node 指针"]
ReturnErr --> End(["结束"])
ReturnNode --> End
```

**图表来源**
- [context.go](file://context.go#L366-L390)
- [pipeline.go](file://pipeline.go#L1-L120)

## 依赖关系分析
- **Context 与 Tasker 的耦合**
  - Context 通过 GetTasker() 获取 Tasker 实例，用于查询任务详情与作业
  - Context 通过 GetTaskJob() 基于当前上下文的任务 ID 与 Tasker 的状态/等待函数构造 TaskJob
- **Context 与原生接口的耦合**
  - 所有执行类方法最终调用 MaaContext* 原生接口
  - 数据传递通过缓冲区（图像、字符串、字符串列表）完成
- **Context 与 Pipeline/Node 的关系**
  - GetNodeJSON/GetNode 用于读取节点配置，结合 OverridePipeline/OverrideNext/OverrideImage 实现动态覆盖
  - RunRecognitionDirect/RunActionDirect 直接使用 NodeRecognitionParam 和 NodeActionParam
- **缓冲区的作用**
  - ImageBuffer：将 image.Image 转换为底层可识别的原始数据
  - StringBuffer：用于字符串的跨语言传递与读取
  - StringListBuffer：用于字符串列表的传递（如 OverrideNext）
- **节点参数类型系统**
  - NodeRecognitionParam 和 NodeActionParam 提供类型安全的参数定义
  - 支持多种识别和动作类型，提供丰富的配置选项

```mermaid
graph LR
Ctx["Context"] --> Tsk["Tasker"]
Ctx --> N["MaaContext* 原生接口"]
Ctx --> ImgBuf["ImageBuffer"]
Ctx --> StrBuf["StringBuffer"]
Ctx --> StrList["StringListBuffer"]
Ctx --> Pipe["Pipeline/Node"]
Ctx --> NodeTypes["NodeRecognitionParam<br/>NodeActionParam"]
```

**图表来源**
- [context.go](file://context.go#L1-L472)
- [tasker.go](file://tasker.go#L1-L120)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go#L1-L130)
- [internal/buffer/string_buffer.go](file://internal/buffer/string_buffer.go#L1-L58)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)
- [node.go](file://node.go#L1-L549)
- [node_recognition.go](file://node_recognition.go#L1-L861)
- [node_action.go](file://node_action.go#L1-L864)

**章节来源**
- [context.go](file://context.go#L1-L472)
- [tasker.go](file://tasker.go#L1-L120)
- [internal/buffer/image_buffer.go](file://internal/buffer/image_buffer.go#L1-L130)
- [internal/buffer/string_buffer.go](file://internal/buffer/string_buffer.go#L1-L58)
- [internal/native/framework.go](file://internal/native/framework.go#L194-L206)
- [node.go](file://node.go#L1-L549)
- [node_recognition.go](file://node_recognition.go#L1-L861)
- [node_action.go](file://node_action.go#L1-L864)

## 性能考量
- **缓冲区生命周期**
  - 图像与字符串缓冲在使用后应销毁，避免内存泄漏
  - 在识别/动作执行中，图像缓冲应在 defer 中销毁
- **JSON 序列化开销**
  - override 参数若为复杂对象，序列化会产生额外开销；建议仅传递必要字段
- **作业等待策略**
  - 使用 TaskJob.Wait() 阻塞等待任务完成，避免频繁轮询状态
- **命中计数与节点属性**
  - 合理使用 MaxHit、PreDelay、PostDelay 等属性，减少无效识别与动作
- **直接执行方法的优势**
  - RunRecognitionDirect 和 RunActionDirect 避免了流水线查找开销
  - 直接参数传递减少了中间步骤，提高执行效率

## 故障排查指南
- **RunTask/RunRecognition/RunAction 返回错误**
  - 检查 override 是否正确序列化为 JSON
  - 检查图像/矩形缓冲是否正确设置与销毁
  - 检查 Tasker 是否已绑定资源与控制器
  - 查看具体的错误信息以确定失败原因
- **RunRecognitionDirect/RunActionDirect 返回错误**
  - 确认 NodeRecognitionParam/NodeActionParam 类型正确
  - 检查参数是否符合对应类型的约束
  - 验证图像格式与尺寸满足底层要求
- **GetNode 返回错误**
  - 确认节点名称是否存在
  - 确认 JSON 解析是否符合 Node 结构
- **OverrideNext 不生效**
  - 确认节点名称与下一跳列表正确
  - 确认在 RunTask 之前调用
- **OverrideImage 不生效**
  - 确认图像资源名与实际资源一致
  - 确认图像格式与尺寸满足底层要求
- **锚点与命中计数**
  - SetAnchor/GetAnchor 成功与否取决于底层是否支持
  - GetHitCount/ClearHitCount 返回值需检查节点名是否正确
- **WaitFreezes 返回 false**
  - 检查检测区域设置是否合理
  - 调整等待参数（阈值、方法、超时等）

**章节来源**
- [context.go](file://context.go#L1-L472)
- [tasker.go](file://tasker.go#L1-L120)
- [context_test.go](file://context_test.go#L1-L1460)

## 结论
Context 为任务执行提供了强大的运行时控制能力，通过 override 参数的灵活支持与丰富的上下文操作（流水线覆盖、节点数据读取、锚点与命中计数），开发者可以在自定义识别与动作中实现高度动态的行为。新增的直接执行方法（RunRecognitionDirect 和 RunActionDirect）进一步增强了灵活性，允许开发者绕过流水线入口直接执行识别和动作。改进的错误处理机制提供了更详细的错误信息，有助于快速定位问题。配合 Tasker 的作业管理与原生接口的高效调用，Context 能够满足复杂自动化场景的需求。

## 附录
- **常见使用模式**
  - 自定义识别中临时覆盖识别参数并执行识别
  - 自定义动作中根据识别结果动态调整动作参数
  - 在同一上下文中克隆出独立上下文，分别执行不同配置的任务
  - 使用 OverrideNext 动态切换下一跳节点顺序
  - 使用 OverrideImage 替换模板图或检测图
  - 使用 RunRecognitionDirect 和 RunActionDirect 进行快速测试
  - 使用 WaitFreezes 进行屏幕稳定性检测
- **示例参考**
  - [examples/custom-recognition/main.go](file://examples/custom-recognition/main.go#L44-L77)
  - [context_test.go](file://context_test.go#L1393-L1460)